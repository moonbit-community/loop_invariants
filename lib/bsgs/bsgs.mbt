// ============================================================================
// BABY-STEP GIANT-STEP - Discrete Logarithm
// ============================================================================
//
// Finds x such that a^x ≡ b (mod p) in O(√p) time and space.
// Works when p is prime and a is a primitive root.
//
// KEY INSIGHT: Write x = im + j where m = ⌈√p⌉.
// Then a^(im+j) ≡ b (mod p) → a^j ≡ b * (a^(-m))^i (mod p)
//
// ALGORITHM:
// 1. Baby steps: Compute a^j mod p for j = 0, 1, ..., m-1. Store in hash table.
// 2. Giant steps: Compute b * (a^(-m))^i mod p for i = 0, 1, ..., m-1.
// 3. If giant step value matches baby step, x = im + j.
//
// INVARIANTS:
// 1. All baby step values a^j are distinct (if a is generator)
// 2. Solution exists iff b is in the group generated by a
// 3. x ∈ [0, p-2] for prime p
//
// TIME COMPLEXITY: O(√p)
// SPACE COMPLEXITY: O(√p)

///|
/// Modular exponentiation
fn bsgs_mod_pow(a : Int64, exp : Int64, m : Int64) -> Int64 {
  let mut result = 1L
  let mut base = a % m
  let mut e = exp

  while e > 0L {
    if e % 2L == 1L {
      result = result * base % m
    }
    base = base * base % m
    e = e / 2L
  }

  result
}

///|
/// Modular multiplicative inverse using Fermat's little theorem
fn bsgs_mod_inverse(a : Int64, p : Int64) -> Int64 {
  bsgs_mod_pow(a, p - 2L, p)
}

///|
/// Baby-step giant-step algorithm for discrete logarithm
/// Finds x such that a^x ≡ b (mod p), returns None if no solution
fn baby_giant(a : Int64, b : Int64, p : Int64) -> Int64? {
  if p <= 1L {
    return None
  }

  // Special case: a = 0
  if a % p == 0L {
    if b % p == 0L {
      return Some(1L)
    } else {
      return None
    }
  }

  // Special case: b = 1
  if b % p == 1L {
    return Some(0L)
  }

  // m = ceil(sqrt(p))
  let m = sqrt_ceil(p)

  // Baby steps: compute a^j for j = 0, 1, ..., m-1
  let baby_steps : Map[Int64, Int64] = {}
  let mut val = 1L
  for j = 0L; j < m; j = j + 1L {
    if not(baby_steps.contains(val)) {
      baby_steps[val] = j
    }
    val = val * a % p
  }

  // Giant step multiplier: a^(-m) mod p
  let a_inv_m = bsgs_mod_inverse(bsgs_mod_pow(a, m, p), p)

  // Giant steps: compute b * (a^(-m))^i for i = 0, 1, ..., m-1
  let mut gamma = b % p
  for i = 0L; i < m; i = i + 1L {
    if baby_steps.contains(gamma) {
      let j = baby_steps[gamma]
      return Some(i * m + j)
    }
    gamma = gamma * a_inv_m % p
  }

  None
}

///|
fn sqrt_ceil(n : Int64) -> Int64 {
  if n <= 0L {
    return 0L
  }
  let mut x = n
  let mut y = (x + 1L) / 2L
  while y < x {
    x = y
    y = (x + n / x) / 2L
  }
  if x * x < n { x + 1L } else { x }
}

///|
/// Discrete logarithm in cyclic group of order n
/// Finds x such that a^x ≡ b (mod p) where order of a is n
fn discrete_log(a : Int64, b : Int64, p : Int64, n : Int64) -> Int64? {
  if n <= 0L {
    return None
  }

  let m = sqrt_ceil(n)

  let baby_steps : Map[Int64, Int64] = {}
  let mut val = 1L
  for j = 0L; j < m; j = j + 1L {
    if not(baby_steps.contains(val)) {
      baby_steps[val] = j
    }
    val = val * a % p
  }

  let a_inv_m = bsgs_mod_inverse(bsgs_mod_pow(a, m, p), p)

  let mut gamma = b % p
  for i = 0L; i < m; i = i + 1L {
    if baby_steps.contains(gamma) {
      let j = baby_steps[gamma]
      let result = i * m + j
      if result < n {
        return Some(result)
      }
    }
    gamma = gamma * a_inv_m % p
  }

  None
}

///|
/// Check if a is a primitive root modulo p (p prime)
fn is_primitive_root(a : Int64, p : Int64) -> Bool {
  if p <= 1L {
    return false
  }
  if p == 2L {
    return a % 2L == 1L
  }

  let phi = p - 1L

  // Find prime factors of phi
  let factors = prime_factors_simple(phi)

  for i = 0; i < factors.length(); i = i + 1 {
    let q = factors[i]
    if bsgs_mod_pow(a, phi / q, p) == 1L {
      return false
    }
  }

  true
}

///|
fn prime_factors_simple(n : Int64) -> Array[Int64] {
  let result : Array[Int64] = []
  let mut num = n

  let mut d = 2L
  while d * d <= num {
    if num % d == 0L {
      result.push(d)
      while num % d == 0L {
        num = num / d
      }
    }
    d = d + 1L
  }
  if num > 1L {
    result.push(num)
  }

  result
}

///|
/// Find a primitive root modulo p (p prime)
fn find_primitive_root(p : Int64) -> Int64? {
  if p <= 1L {
    return None
  }
  if p == 2L {
    return Some(1L)
  }

  for g = 2L; g < p; g = g + 1L {
    if is_primitive_root(g, p) {
      return Some(g)
    }
  }

  None
}

// ============================================================================
// POHLIG-HELLMAN for smooth order groups
// ============================================================================

///|
/// Solve discrete log when order has known factorization
/// More efficient when p-1 has small prime factors
fn pohlig_hellman(
  a : Int64,
  b : Int64,
  p : Int64,
  factors : Array[(Int64, Int)]
) -> Int64? {
  // For each prime power factor p_i^e_i of (p-1):
  // Compute x mod p_i^e_i using repeated baby-step giant-step
  // Combine using CRT

  let n = p - 1L
  let remainders : Array[Int64] = []
  let moduli : Array[Int64] = []

  for i = 0; i < factors.length(); i = i + 1 {
    let (q, e) = factors[i]
    let mut q_pow = 1L
    for j = 0; j < e; j = j + 1 {
      q_pow = q_pow * q
    }

    // Compute x mod q^e
    let a_exp = n / q_pow
    let aa = bsgs_mod_pow(a, a_exp, p)
    let bb = bsgs_mod_pow(b, a_exp, p)

    match baby_giant(aa, bb, p) {
      Some(x) => {
        remainders.push(x % q_pow)
        moduli.push(q_pow)
      }
      None => return None
    }
  }

  // Combine using CRT
  crt_solve(remainders, moduli)
}

///|
fn crt_solve(remainders : Array[Int64], moduli : Array[Int64]) -> Int64? {
  if remainders.length() == 0 {
    return Some(0L)
  }

  let mut result = remainders[0]
  let mut m = moduli[0]

  for i = 1; i < remainders.length(); i = i + 1 {
    let a2 = remainders[i]
    let m2 = moduli[i]

    // Solve result + m*t ≡ a2 (mod m2)
    let (g, x, _) = extended_gcd_bsgs(m, m2)
    if (a2 - result) % g != 0L {
      return None
    }

    let t = ((a2 - result) / g * x) % (m2 / g)
    result = result + m * t
    m = m * (m2 / g)
    result = ((result % m) + m) % m
  }

  Some(result)
}

///|
fn extended_gcd_bsgs(a : Int64, b : Int64) -> (Int64, Int64, Int64) {
  if b == 0L {
    return (a, 1L, 0L)
  }
  let (g, x1, y1) = extended_gcd_bsgs(b, a % b)
  (g, y1, x1 - (a / b) * y1)
}

// ============================================================================
// TESTS
// ============================================================================

///|
test "baby_giant simple" {
  // Find x such that 2^x ≡ 8 (mod 13)
  // 8 = 2^3, so x = 3
  match baby_giant(2L, 8L, 13L) {
    Some(x) => inspect(bsgs_mod_pow(2L, x, 13L), content="8")
    None => fail("Expected solution")
  }
}

///|
test "baby_giant identity" {
  // Find x such that a^x ≡ 1 (mod p)
  // x = 0 is always a solution
  match baby_giant(5L, 1L, 17L) {
    Some(x) => inspect(x, content="0")
    None => fail("Expected solution")
  }
}

///|
test "baby_giant base" {
  // Find x such that a^x ≡ a (mod p)
  // x = 1
  match baby_giant(3L, 3L, 11L) {
    Some(x) => inspect(bsgs_mod_pow(3L, x, 11L), content="3")
    None => fail("Expected solution")
  }
}

///|
test "baby_giant larger" {
  // 3^5 = 243 ≡ 243 mod 997
  let a = 3L
  let b = 243L
  let p = 997L

  match baby_giant(a, b, p) {
    Some(x) => inspect(bsgs_mod_pow(a, x, p), content="243")
    None => fail("Expected solution")
  }
}

///|
test "is_primitive_root" {
  // 2 is a primitive root mod 5
  inspect(is_primitive_root(2L, 5L), content="true")
  // 4 is not (4^2 = 16 ≡ 1 mod 5)
  inspect(is_primitive_root(4L, 5L), content="false")
}

///|
test "find_primitive_root" {
  match find_primitive_root(7L) {
    Some(g) => inspect(is_primitive_root(g, 7L), content="true")
    None => fail("Expected primitive root")
  }
}

///|
test "discrete_log with order" {
  // Order of 2 mod 13 is 12
  match discrete_log(2L, 8L, 13L, 12L) {
    Some(x) => inspect(bsgs_mod_pow(2L, x, 13L), content="8")
    None => fail("Expected solution")
  }
}

///|
test "baby_giant no solution" {
  // 2^x cannot equal 0 mod p for any x
  // Actually testing with a non-residue
  // This depends on specific group structure
  // Just test that algorithm handles it
  let result = baby_giant(2L, 0L, 13L)
  inspect(result is None, content="true")
}

///|
test "mod_pow" {
  inspect(bsgs_mod_pow(2L, 10L, 1000L), content="24")
  inspect(bsgs_mod_pow(3L, 0L, 100L), content="1")
}

///|
test "sqrt_ceil" {
  inspect(sqrt_ceil(16L), content="4")
  inspect(sqrt_ceil(17L), content="5")
  inspect(sqrt_ceil(1L), content="1")
}
